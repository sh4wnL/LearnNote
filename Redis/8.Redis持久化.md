# Redis的持久化



> Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能



## RDB（Redis DataBase）



### 什么是RDB

![image-20210122151335281](8.Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20210122151335281.png)

在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，他恢复时是将快照文件直接读到内存里。

> Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。RDB缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置。



==rdb保存的文件是dump.rdb==



### 触发机制

1. save的规则满足的情况下，会自动触发rdb规则
2. 执行flushall 命令，也会触发我们的rdb规则
3. 退出redis，也会产生rdb文件

备份就自动产生一个rdb文件



### 如果恢复rdb文件

1. 只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb恢复其中的数据
2. 查看需要存在的位置

```bash
127.0.0.1:6379> config get dir
1) "dir"
2) "/usr/local/bin"  # 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据
```

优点：

1. 适合大规模的数据恢复
2. 对数据的完整性要求不高

缺点：

1. 需要一定的时间间隔进程操作，如果redis意外宕机了，这个最后一次修改的数据就没有了
2. fork进程的时候，会占用一定的内存空间



## AOF（Append Only File）

![image-20210124120932696](8.Redis%E6%8C%81%E4%B9%85%E5%8C%96.assets/image-20210124120932696.png)

将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍

> 以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

```bash
appendonly no # 默认不开启 aof 使用rdb方式持久化   默认不开启AOF

# The name of the append only file (default:"appendonly.aof")
appendfilename "appendonly.aof"   # 默认文件名
```

如果这个aof文件有错位，这时候 redis是启动不起来的，我们需要修复这个aof文件

redis给我们提供了一个工具  ==redis-check-aof --fix==

### 优点：

1. 每一次修改都同步，文件的完整性会更加好
2. 每秒同步一次，可能会丢失一秒的数据
3. 从不同步，效率最高

### 缺点：

1. 相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢
2. AOF运行效率也要比RDB慢，所以我们Redis默认的配置就是RDB持久化



## 总结

1. RDB持久化方式能够在指定的时间间隔内对你的数据进行快照存储
2. AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。
3. ==只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化==
4. 同时开启两种持久化方式
   - 在这种情况下，当redis重启的时候回优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。
   - RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。

5. 性能建议
   - 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。
   - 如果Enable AOF，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite的最后将rewrite的过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小 100%大小重写可以改到适当的数值。
   - 如果不Enable AOF，仅靠Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave同时倒掉，会丢失十几分钟数据，启动脚本也要比较两个Master/Slave中的RDB文件，载入较新的那个，微博就是这种架构