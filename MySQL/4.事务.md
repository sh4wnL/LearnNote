[toc]

\## 什么是事务

\> 在数据库系统里而言，事务是代表一个或者一系列操作的最小逻辑单元，所有在这个逻辑单元内的操作要么全部成功，要么就全部失败，不存在任何中间状态，一旦事务失败那么所有的更改都会被撤消，一旦事务成功所有的操作结果都会被保存。

\##### 案例：转账

\> A账户余额有1000元，B账户余额0元，在这个基础上A向B转账400元，流程如下：

\1. 查询A账户余额，看金额是>=400元。

\1. 满足条件则先从A账户扣款400元（当前A余额=600、当前余=0）。

\1. 然后再向B账户增加400元（当前A余额=600、当前B余额=400）。

\## 事务的ACID原则

\> 要实现事务的最终目的，需要几种机制组合才能实现，这几种机制就是事务的几个特性，分别原子性、隔离性、一致性、持久性。 用一句话总结来总结这几个特性之间的关系，那就是“一致性是事务的最终目的，而==原子性、隔离性、持久性其实都是为了实现一致性的手段==”。

\#### 1.原子性(atomicity)

\> 概念：一个事务必须是一系列操作的最小单元，这系列操作的过程中，要么整个执行，要么整个回滚，不存在只执行了其中某一个或者某几个步骤。

\> 对应到上面的转账操作中，原子性就代表（检查余额、转账、到账）三个步骤就是一个整体，少了任何一个都不能称为一次转账，整个过程中检查余额、转账、到账要么整体都执行，要么一个失败就整体失败，绝对不会出现某一个执行成功其它的都执行失败，或者某一个执行失败其它的操作执行成功的情况。

\#### 2.一致性(consistency)

\> 概念：事务要保证数据库整体数据的完整性和业务的数据的一致性，事务成功提交整体数据修改，事务错误则回滚到数据回到原来的状态；

\> 如上面转账的案例，如果事务提交成功则A账户减金额，B账户则加对应的金额，数据库总体金额不变只是载体变了。如果事务出错则整体回滚，无论到了上面的哪个步骤A和B的数据都会回到最事务开启前的状态保证数据的始终一致;

\#### 3.隔离性(isolation)

\> 概念：隔离性是说两个事务的执行都是独立隔离开来的，事务之前不会相互影响，多个事务操作一个对象时会以串行等待的方式保证事务相互之间是隔离的：

\> 小明和小芳各自有一本作业本，如果他们同时去写作业，这时他们都可以在各自作业本上写作业是相互不影响的。但是如果他们两个人只有一本作业本，但是他们都想去写作业怎么办，那么就这个时候就只能等一个人先写完作业后，另外一个人才能写，要不然两个人同时在同一个作业本上写作业，那么肯定会乱套。所以这种两个事物操作同一个对象必须隔离开来不能相互影响的特性称为事务的隔离性。

\#### 4.持久性(durability)

\> 概念：持久性是指一旦事务成功提交后，只要修改的数据都会进行持久化，不会因为异常、宕机而造成数据错误或丢失。

\### 对原子性和一致性区别的认识

\> 原子性并不能保证一致性。再多个事务并行进行的情况下，即使保证每一个事务的原子性，仍然可能导致数据不一致的结果。

举例：

\> 事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上，事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。

如上，保证了原子性，但是数据库的一致性没有得到保证，上述这种情况就需要数据库隔离性的保证了。

\## 第一类丢失更新 （Lost Update）

在完全未隔离事务的情况下，两个事务更新同一条数据资源，某一事务完成，另一事务异常终止，回滚造成第一个完成的更新也同时丢失 。这个问题现代关系型数据库已经不会发生，

\## 脏读（Dirty Read）

A事务执行过程中，B事务读取了A事务的修改。但是由于某些原因，A事务可能没有完成提交，发生RollBack了操作，则B事务所读取的数据就会是不正确的。这个未提交数据就是脏读（Dirty Read）。

\## 不可重复读（Nonrepeatable Read）

B事务读取了两次数据，在这两次的读取过程中A事务修改了数据，B事务的这两次读取出来的数据不一样。B事务这种读取的结果，即为不可重复读（Nonrepeatable Read）。

\### 不可重复读特殊情况：第二类丢失更新

两个事务更新同一条数据资源，后完成的事务会造成先完成的事务更新丢失。

\## 幻读（Phantom Read）

B事务读取了两次数据，在这两次的读取过程中A事务添加了数据，B事务的这两次读取出来的集合不一样。

\### 幻读与不可重复读的区别：

幻读强调的是集合的增减，而不是单独一条数据的修改

## 数据库隔离级别



### 读未提交（ReadUncommitted)

> 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别是最低的隔离级别，虽然拥有超高的并发处理能力及很低的系统开销，但很少用于实际应用。因为采用这种隔离级别只能防止第一类更新丢失问题，不能解决脏读，不可重复读及幻读问题

### 读已提交（Read Committed）

> 这是大多数数据库系统默认隔离级别（但不是MySQL默认的）。他满足了隔离的简单定义：一个事物只能看见已经提交事务所做的改变。这种隔离级别可以防止脏读问题，但会出现不可重复读以及幻读问题。

### 可重复读（Repeatable Read)

> 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。这种隔离级别可以防止除幻读外的其他问题。

### 可串行化 （Serializable）

> 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读、第二类更新丢失问题。在这个级别，可以解决上面提到的所有并发问题，但可能导致大量的超时现象和锁竞争，通常数据库不会用这个隔离级别，我们需要其他的机制来解决这些问题：乐观锁和悲观锁。

## 四种隔离级别会产生的问题

| 隔离级别         | 脏读 | 不可重复读 | 幻读 | 第一类丢失更新 | 第二类丢失更新 |
| ---------------- | ---- | ---------- | ---- | -------------- | -------------- |
| Read Uncommitted | Yes  | Yes        | Yes  | No             | Yes            |
| Read Commited    | No   | Yes        | Yes  | No             | Yes            |
| Repeatable Read  | No   | No         | Yes  | No             | No             |
| Serializable     | No   | No         | No   | No             | No             |

