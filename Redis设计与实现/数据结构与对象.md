 # 数据结构与对象

## 简单动态字符串（SDS）

### SDS的定义

> 定义
>
> ```c
> struct sdshdr {
>   // 记录buf数组中已使用字节的数量
>   // 等于SDS所保存字符串的长度
>   int len;;
>   
>   // 记录buf数组中未使用字节的数量
>   int free;
>   
>   // 字节数组，用于保存字符串
>   char buf[];
> };
> ```

### SDS与C字符串的区别

#### 1. 常数复杂度获取字符串长度

| 数据结构 | strlen时间复杂度 |
| -------- | ---------------- |
| char[]   | O(n)             |
| SDS      | O(1)             |

#### 2. 杜绝缓冲区溢出

char[]在进行strcat的拼接操作时可能会因为目标字符串后没有足够空间而造成缓冲区溢出失败

SDS在API设置了先行检查空间是否满足要求的操作，使对空间的考虑透明化

#### 3. 减少修改字符串时带来的内存重分配次数

> 针对于append操作需要分配内存，trim操作需要释放内存的操作，SDS实现了以下两种优化策略

##### 1> 空间预分配

- 如果对SDS修改之后，长度小于1MB，则程序分配和len属性同样大小的未使用空间，此时len == free。
- 如果对SDS修改之后，长度大于1MB，则程序分配1MB的未使用空间。

##### 2> 惰性空间分配

- 在删除SDS中的字符后，不释放空间，，而采用free记录的策略。

#### 4. 二进制安全

> 所有SDS API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样的，它被读取时就是什么样。
>
> Redis不是用SDS保存字符，，而是用它来保存一系列二进制数据。

#### 5. 兼容部分C字符串函数

> 借助SDS仍会在末尾设置'\0'的特性，SDS仍可使用C语言定义的函数

#### 6. 总结

| C字符串                                    | SDS                                        |
| ------------------------------------------ | ------------------------------------------ |
| 获取字符串长度的复杂度为O(N)               | 获取字符串长度的复杂度为O(1)               |
| API是不安全的，可能会造成缓冲区溢出        | API是安全的，不会造成缓冲区溢出            |
| 修改字符串长度N次必然需要执行N次内存重分配 | 修改字符串长度N次最多需要执行N次内存重分配 |
| 只能保存文本数据                           | 可以保存文本或者二进制数据                 |
| 可以使用所有<string.h>库中的函数           | 可以使用一部分<string.h>库中的函数         |

### SDS API

| 函数        | 作用                                                         | 时间复杂度                                              |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| sdsnew      | 创建一个包含给定C字符串的SDS                                 | O(N), N为给定C字符串的长度                              |
| sdsempty    | 创建一个不包含任何内容的空SDS                                | O(1)                                                    |
| sdsfree     | 释放给定的SDS                                                | O(N), N为被释放SDS的长度                                |
| sdslen      | 返回SDS的已使用空间字节数                                    | 这个值可以通过读取SDS的len属性来直接获得，复杂度为O(1)  |
| sdsavail    | 返回SDS的未使用空间字节数                                    | 这个值可以通过读取SDS的free属性来直接获得，复杂度为O(1) |
| sdsdup      | 创建一个给定SDS的副本（copy）                                | O(N), N为给定SDS的长度                                  |
| sdsclear    | 清空SDS保存的字符串内容                                      | 因为惰性空间释放策略，复杂度为O(1)                      |
| sdscat      | 将给定C字符串拼接到SDS字符串的末尾                           | O(N)， N为被拼接C字符串的长度                           |
| sdscatsds   | 将给定SDS字符串拼接到另一个SDS字符串的末尾                   | O(N)， N为被拼接SDS字符串的长度                         |
| sdscpy      | 将给定的C字符串复制到SDS里面，覆盖SDS原有的字符串            | O(N), N为被复制C字符串的长度                            |
| sdsgrowzero | 用空字符将SDS扩展至给定长度                                  | O(N), N为扩展新增的字节数                               |
| sdsrange    | 保留SDS给定区间内的数据，不在区间内的数据会被覆盖或清除      | O(N), N为被保留数据的字节数                             |
| sdstrim     | 接受一个SDS和一个C字符串作为参数，从SDS中移除所有在C字符串中出现过的字符 | O(N^2), N为给定C字符串的长度                            |
| sdscmp      | 对比两个SDS字符串是否相同                                    | O(N)，N为两个SDS中较短的那个SDS的长度                   |

### 重点回顾

比起C字符串，SDS具有以下优点

1. 常数复杂度获取字符串长度
2. 杜绝缓冲区溢出
3. 减少修改字符串长度时所需的内存重分配次数
4. 二进制安全
5. 兼容部分C字符串函数



## 链表

### 链表和链表节点的实现

> 定义
>
> ```c
> typedef struct listNode {
>   //前置节点
>   struct listNode *prev；
>   
>   //后置节点
>   struct listNode *next；
>   
>   //节点的值
>   void *value;
> }listNode;
> 
> typedef struct list {
>   // 表头节点
>   listNode *head;
>   
>   // 表尾节点
>   listNode *tail;
>   
>   // 链表所包含的节点数量
>   unsigned long len;
>   
>   // 节点值复制函数
>   void *(*dup)(void *ptr);
>   
>   // 节点值释放函数
>   void (*tree)(void *ptr);
>   
>   // 节点值对比函数
>   int (*match)(void *ptr, void *key);
> }list;
> ```

##### Redis的链表实现的特性可以总结如下：

- 双端

> 链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)

- 无环

> 表头节点的prev指针和表尾节点的next指针都指向NULL， 对链表的访问以NULL为终点

- 带表头指针和表尾指针

> 通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为O(1)

- 带链表长度计数器

> 程序使用list结构的len属性来对list持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为O(1)

- 多态

> 链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值

